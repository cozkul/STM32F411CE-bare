/* Label for the program's entry point. Used by debugger only. */
ENTRY(Reset_Handler)
MEMORY
{
/* spaces are syntax critical */
    RAM(rxw)          : ORIGIN = 0x20000000, LENGTH = 128K
    FLASH(rx)         : ORIGIN = 0x08000000, LENGTH = 512K
/* Can define SDRAM here if we had one on the PCB. */
}
/* End of RAM / Start of stack */
/* (4KB SRAM) */
_estack = 0x20020000;
/* _estack = ORIGIN(RAM) + LENGTH(RAM) */
/* Set minimum size for stack and dynamic memory. */
/* (The linker will generate an error if there is
 * less than this much RAM leftover.) */
/* (1KB) */
_Min_Leftover_RAM = 0x400;
_Min_Heap_Size = 0;/* Do not use heap in real-time computing*/
_Min_Stack_Size = 0x400;
SECTIONS
{
/* The vector table goes at the start of flash. */
  .vector_table :
  {
    . = ALIGN(4);
    KEEP (*(.vector_table))
    . = ALIGN(4);
  } >FLASH
/* The 'text' section contains the main program code.
 * Functions stored in subsections of the text section. */
  .text :
  {
    . = ALIGN(4);
    *(.text)/*anything goes into text section*/
    *(.text*)/*anything that is text dot something */
    . = ALIGN(4);
/* Run attribute constructor for global functions before main at startup */
    KEEP (*(.init))
    KEEP (*(.fini))
  } >FLASH
/* The 'rodata' section contains read-only data,
 * constants, strings, information that won't change. */
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)
    *(.rodata*)
    . = ALIGN(4);
  } >FLASH
/* The 'data' section is space set aside in RAM for
 * things like initialized variables, which can change.
 * Data stored at flash but moved to RAM. _sdata and _edata
 * variables tells where data starts and ends. */
  _sidata = .;
  /* .data : AT(_sidata) */
  .data :
  {
    . = ALIGN(4);
/* _sdata variable decleration marks start location
 * for the 'data' section. */
    _sdata = .;
    *(.data)
    *(.data*)
    . = ALIGN(4);
    _edata = .;
  } >RAM AT >FLASH
/* The 'bss' section is similar to the 'data' section,
 * but its space is initialized to all 0s at the
 * start of the program. Uninitialized variables. */
  .bss :
  {
    . = ALIGN(4);
/* Also mark the start/end of the BSS section. */
    _sbss = .;
    __bss_start__ = _sbss;/* support for floating points for libgcc */
    *(.bss)
    *(.bss*)
/* Generated by GCC */
    *(COMMON)
    . = ALIGN(4);
    _ebss = .;
    __bss_end__ = _ebss;
/* Uninitialized data object that is not yet allocated */
/* Uninitialized so no need to put data at FLASH */
  } >RAM
/* Space set aside for the application's heap/stack. */
  .dynamic_allocations :
  {
    . = ALIGN(8);
    _ssystem_ram = .;
    . = . + _Min_Leftover_RAM;
    . = ALIGN(8);
    _esystem_ram = .;
  } >RAM
}
/* Code can be located into these sections explicitly:
 * Example: #define  __dynamic_allocation __attribute__((".dynamic_allocations"))
 *          int __dynamic_allocation var = 123;
 
 * Flexible Static Memory Controller, allows memory mapped peripherals thru AHB on MCU.

 * __attribute__(): compiler attribute - documented in GCC attributes
 * You can place addresses of functions to a section that just contains addresses
 * Then run call functions from startup code. These functions initialize drivers at startup.
 * Attributes can be used to do things in binary 16bit variable can be put in 4 bytes always.*/